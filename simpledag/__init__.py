__version__ = '0.1.0'


import collections


class Dag:
    """Simple directed acyclic graph."""
    def __init__(self):
        self.nodes = set()
        self.edges = collections.defaultdict(set)

    def add_edge(self, start, end):
        """Add an edge to the graph."""
        self.nodes.add(start)
        self.nodes.add(end)
        self.edges[start].add(end)
        return self

    def children(self, node):
        """Obtain the children of a node in a graph."""
        return list(self.edges[node])

    def parents(self, node):
        """Obtain the parents of a node in a graph."""
        return [n for n in self.edges.keys() if node in self.edges[n]]

    def roots(self):
        """Obtain the roots of the graph."""
        return [n for n in self.edges.keys() if self.parents(n) == []]

    def invert(self):
        """Invert the graph."""
        dag = Dag()
        for s, es in self.edges.items():
            for e in es:
                dag.add_edge(e,s)
        return dag


def closure(graph, nodes):
    """Get the subgraph generated by a collection of nodes."""

    def children(nodes):
        """Get children of a collection of nodes"""
        return [(n, c) for n in nodes for c in graph.children(n)]

    dag = Dag()
    while nodes:
        for n, c in children(nodes):
            dag.add_edge(n, c)
        nodes = [e[1] for e in children(nodes)]

    return dag


def ranked_walk(graph, start_depth=0):
    """
    Topological walk of the graph.

    Ranks the nodes by depth.
    """
    def _walk(queue, next_queue, postponed, depth):
        """Continuation passing walker."""

        def queue_or_postpone_child_of(n, c):
            """
            Track that we have visited the parent n of c.

            If we have visited all parents of c, queue c.
            In all cases remove n from the set of unvisited parents
            of c.
            """
            not_traversed = postponed.get(c, set(graph.parents(c)))
            not_traversed.remove(n)
            postponed[c] = not_traversed
            if not not_traversed:
                next_queue.append(c)

        def queue_or_postpone_children(n):
            """Helped to decide when to queue child nodes."""
            children = graph.children(n)
            for c in children:
                queue_or_postpone_child_of(n, c)

        if queue:
            # First we process the queue
            head = queue[0]
            queue_or_postpone_children(head)
            cont = lambda: _walk(queue[1:], next_queue, postponed, depth)
            return (depth, head, cont)
        elif next_queue:
            # Then we increase the depth and take the next layer of nodes
            head = next_queue[0]
            queue_or_postpone_children(head)
            cont = lambda: _walk(next_queue[1:], [], postponed, depth + 1)
            return (depth + 1, head, cont)
        else:
            # Otherwise there is nothing left
            return None

    node = _walk(graph.roots(), [], {}, start_depth)
    while node:
        depth, n, cont = node
        yield depth, n
        node = cont()


def topological_walk(graph):
    """Topological walk of the graph."""
    for _, n in ranked_walk(graph):
        yield n

